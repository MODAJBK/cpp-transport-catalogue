# **Transport-catalogue**
## **Описание**
**Транспортный справочник** – проект, функциональная составляющая которого направлена на поддерживание системы хранения остановок и транспортных маршрутов и обработку запросов к этой системе.
## **Функционал**
* Построение базы данных остановок и транспортных маршрутов с помощью входного _JSON_-объекта;
* Получение информации о конкретном маршруте по его номеру, включающей длину маршрута, количество остановок и его кривизну;
* Получение информации о конкретной остановке, включающей в себя список автобусов, проходящих через нее;
* Получение карты маршрутов, построенной на основе полученных входных данных;
* Получение кратчайшего маршрута между двумя заданными остановками;
* Ответы на запросы формируются в виде _JSON_-документа.
* Поддержка сериализации базы данных и настроек справочника с использованием _Protobuf_.
## **Сборка и запуск**
1. Для работы с проектом необходимо установить и собрать [_Protobuf_](https://github.com/protocolbuffers).
2. Осуществить сборку проекта посредством утилиты _CMake_.
3. После сборки запустить исполняемый файл `transport_catalogue.exe`.
## **Работа с проектом**
### **make_base**
Предварительно необходимо заполнить базу данных остановок и транспортных маршрутов, а также задать определенные настройки и произвести сериализацию с помощью команды `make_base` и входного _JSON_-документа вида:
```
{
  "base_requests": [ ... ],
  "render_settings": { ... },
  "routing_settings": { ... },
  "serialization_settings": { ... },
}
```
### 1) **base_requests**

`base_requests` содержит в себе список маршрутов и автобусных остановок, задающихся в следующих форматах:
Для маршрута
```
{
  "type": "Bus",
  "name": "route_name",
  "stops": [...],
  "is_roundtrip": ...
}
```
* `"type": "Bus"` указывает, что запрос задает маршрут. 
* `"name"` задает имя для конкретного маршрута.
* `"stops"` включает в себя перечисление названий остановок для данного маршрута, обратите внимание, что все остановки должны быть существующими, то есть находится в базе данных.
* `"is_roundtrip"` булевое поле, задающее является ли маршрут кольцевым или нет. Ниже на изображениях показаны схематические изображения для кольцевого и линейного маршрутов.

-Кольцевой

![Cycle_route](https://github.com/MODAJBK/cpp-transport-catalogue/assets/104262620/87a61393-0632-40a8-94cc-47707c9f4a46)

-Линейный

![Nonecycle_route](https://github.com/MODAJBK/cpp-transport-catalogue/assets/104262620/48c425e6-9eb9-4072-9672-d27e1e096c5a)

Для остановки
```
{
  "type": "Stop",
  "name": "stop_name",
  "latitude": ...,
  "longitude": ...,
  "road_distances": {...}
}
```
* `"type": "Stop"` указывает, что запрос задает остановку.
* `"name"` задает имя для конкретной остановки.
* `"latitude"` и `"longitude"` задают широту и долготу остановки в виде вещественного числа, соответственно.
* `"road_distances"` задает расстояние до ближайших остановок в формате:  `"stop_name": distance`.

### 2) **render_settings**

`render_settings` словарь, содержащий необходимые для рисования карты настройки.
```
{
  "width": ...,
  "height": ...,
  "padding": ...,
  "stop_radius": ...,
  "line_width": ...,
  "bus_label_font_size": ...,
  "bus_label_offset": [...],
  "stop_label_font_size": ...,
  "stop_label_offset": [...],
  "underlayer_color": [...],
  "underlayer_width": ...,
  "color_palette": [...]
}
```
* `"width"` и `"height"` - ширина и высота изображения в пикселях, вещественное число в диапазоне от 0 до 100000.
* `"padding"` - отступ краёв карты от границ SVG-документа, вещественное число не меньше 0 и не больше `min(width, height)/2`.
* `"stop_radius"` - радиус окружностей, которыми обозначаются остановки, вещественное число в диапазоне от 0 до 100000.
* `"line_width"` - толщина линий, которыми рисуются автобусные маршруты, вещественное число в диапазоне от 0 до 100000.
* `"bus_label_font_size"` - размер текста, которым написаны названия автобусных маршрутов, целое число в диапазоне от 0 до 100000.
* `bus_label_offset` - смещение надписи с названием маршрута относительно координат конечной остановки на карте, массив из двух элементов типа `double` (числа в диапазоне от –100000 до 100000) , задаёт значение свойств `dx` и `dy` SVG - элемента `<text>`.
* `"stop_label_font_size"` -  размер текста, которым отображаются названия остановок, целое число в диапазоне от 0 до 100000.
* `"stop_label_offset"` - смещение названия остановки относительно её координат на карте, задается аналогично `"bus_label_offset"`.
* `"underlayer_color"` - цвет подложки под названиями остановок и маршрутов.
* `"underlayer_width"` - толщина подложки под названиями остановок и маршрутов, задаёт значение атрибута `stroke-width` элемента `<text>`, вещественное число в диапазоне от 0 до 100000.
* `"color_palette"` - цветовая палитра, непустой массив.

Цвет можно указывать в одном из следующих форматов: в виде строки, например `"red"` или `"black"`; в массиве из трёх целых чисел диапазона [0, 255], они определяют `r`, `g` и `b` компоненты цвета в формате `svg::Rgb`; в массиве из четырёх элементов: три целых числа в диапазоне от [0, 255] и одно вещественное число в диапазоне от [0.0, 1.0], они задают составляющие `red`, `green`, `blue` и `opacity` цвета формата `svg::Rgba`.
### 3) **routing_settings**

`routing_settings` - словарь, содержащий настройки для построения кратчайшего маршрута между двумя остановками
```
{
   "bus_wait_time": ...,
   "bus_velocity": ...
}
```
* `"bus_wait_time"` - время ожидания автобуса на остановке, в минутах. Считается, что когда бы человек ни пришёл на остановку и какой бы ни была эта остановка, он будет ждать любой автобус в точности указанное количество минут. Значение — целое число от 1 до 1000.
* `"bus_velocity"` - скорость автобуса, в км/ч. Считается, что скорость любого автобуса постоянна и в точности равна указанному числу. Время стоянки на остановках не учитывается, время разгона и торможения тоже. Значение — вещественное число от 1 до 1000.
### 4) **serialization_settings**

`serialization_settings` - содержит настройки сериализации.
```
{
  "file": "file_name"
}
```
* `"file"` - строка, соответствующая названию файла, куда будут записаны данные после сериализации.
### process_requests
После заполнения базы данных можно запустить программу с командой `process_requests` и передать ей на вход _JSON_-документ для выполнения запросов к транспортному справочнику.
```
}
  "serialization_settings": { ... },
  "stat_requests": [...]
}
```
### 1) **serialization_settings**

`"serialization_settings"` имеет аналогичную структур с одноименным полем при выполнении построения базы данных. В данном случае `"file"` указывает название файла, из которого будет происходит десериализация транспортного справочника.
### 2) **stat_requests**

`stat_requests` содержит запросы к транспортному справочнику, всего имеется четыре вида запросов.

### **Получение информации о маршруте/остановке**
```
{
  "id": ...,
  "type": ...,
  "name": ...
}
```
* `"id"` - идентификатор запроса;
* `"type"` - тип запроса. `"Bus"` - получение информации о маршруте. `"Stop"` - получение информации об остановке.
* `"name"` - название маршрута/остановки.

Ответ на запрос `"Bus"`:
```
{
  "request_id": ...,
  "curvature": ...,
  "route_length": ...,
  "stop_count": ...,
  "unique_stop_count": ...
}
```
* `"request_id"` - идентификатор запроса;
* `"curvature"` - кривизна маршрута;
* `"route_length"` - длина маршрута;
* `"stop_count"` - общее число остановок;
* `"unique_stop_count"` - число уникальных остановок.

Ответ на запрос `"Stop"`:
```
{
  "request_id": 508658276,
  "buses": [...]
}
```
* `"request_id"` - идентификатор запроса;
* `"buses"` - массив всех маршрутов, которые проходят через конкретную остановку в формате: `"route_name1", "route_name2" ... "route_nameN"`.

### **Рисование карты маршрутов**
```
{
  "id": ...,
  "type": "Map"
}
```
Рисование изображения выполняется посредством разработанной библиотеки для работы с _SVG_ графикой, поддерживающей три типа фигур: круг, ломаная линия, текст, и класса _MapRender_. Для простоты расчетов было принято допущение, что земля представляет собой идеальную сферу радиусом 6371 километр. Относительно этого вычисляется географическое расстояние между двумя точками земной поверхности, заданными их широтой и долготой. После проецирования сферы на плоскость остановки наносятся на изображение.

Пример изображения карты маршрутов

![Map](https://github.com/MODAJBK/cpp-transport-catalogue/assets/104262620/db30bb36-1744-4ed3-ab7a-75be6331b0eb)

### **Определение кратчайшего расстояния между двумя остановками**
```
{
   "id": ...,
   "type": "Route",
   "from": "stop_from_name",
   "to": "stop_to_name"
}
```
* `"id"` - идентификатор запроса;
* `"type"` - тип запроса: `"Route"`;
* `"from"` - название остановки, от которой необходимо построить маршрут;
* `"to"` - название остановки, до которой необходимо построить маршрут.

Построение маршрута между заданными остановками осуществляется посредством классов _DirectedWeightedGraph_, _Router_ и _RouteBuilder_. _DirectedWeightedGraph_ – класс, реализующий взвешенный ориентированный граф, поддерживающий добавление вершин/ребер и их хранение. _Router_ – класс, реализующий поиск кратчайшего пути во взвешенном ориентированном графе. _RouteBuilder_ – класс, выполняющий построение графа и осуществляющий взаимодействий между _DirectedWeightedGraph_ и _Router_.

Ответ на запрос `Route`:
```
{
  "request_id": ...,
  "items": [...],
  "total_time": ...
}
```
* `"request_id"` - идентификатор запроса;
* `"total_time"` - время маршрута;
* `"items"` - массив, содержащий детали маршрута в виде списка:
```
{
   "bus": "route_name",
   "span_count": ...,
   "time": ...,
   "type": "Bus"
},
...
{
  "stop_name": "stop_name",
  "time": ...,
  "type": "Wait"
}
```
* `"bus"` - название одного из маршрутов, по которому необходимо проехать;
* `"span_count"` - число остановок, которое необходимо проехать, двигаясь по конкретному маршруту;
* `"time"` - время, потраченное на заданный элемент пути;
* `"type"` - тип элемента пути: `"Bus"` - поездка на конкретном маршруте, `"Wait"` - ожидание на конкретной остановке.
## **Тестирование**
Весь представленный функционал проекта покрыт модульными тестами с применением разработанного тестового фреймворка, работающего посредством макроопределений.
## **Требования**
Наличие компилятора с поддержкой стандарта C++17 и новее и Google Protobuf.
